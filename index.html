<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ö–æ—Ç–∏–∫ –±–µ–∂–∏—Ç - Dendy Style</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background: #000;
            font-family: 'Courier New', monospace; overflow: hidden; width: 100vw; height: 100vh;
        }
        #gameContainer { position: relative; width: 100%; height: 100%; }
        #gameCanvas { 
            display: block; width: 100%; height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #score {
            position: absolute; top: 10px; left: 10px; font-size: 20px;
            font-weight: bold; color: #fff; background: rgba(0,0,0,0.8);
            padding: 8px 15px; border-radius: 0; border: 2px solid #fff; z-index: 10;
            font-family: 'Courier New', monospace;
        }
        #doubleJumpIndicator {
            position: absolute; top: 10px; right: 10px; font-size: 14px;
            background: rgba(0,0,0,0.8); padding: 8px 15px;
            border-radius: 0; border: 2px solid #fff; z-index: 10;
            color: #0f0; font-family: 'Courier New', monospace;
        }
        #startScreen, #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 30px; border-radius: 0;
            text-align: center; border: 4px solid #fff; z-index: 20;
        }
        #gameOver { display: none; }
        h2 { margin: 0 0 15px 0; color: #ff0; font-size: 24px; font-family: 'Courier New', monospace; }
        p { margin: 10px 0; color: #fff; font-family: 'Courier New', monospace; }
        button {
            margin-top: 15px; padding: 15px 40px; font-size: 18px;
            background: #0f0; color: #000; border: 4px solid #fff;
            cursor: pointer; font-family: 'Courier New', monospace;
        }
        button:active { background: #0a0; }
        
        /* Scanline effect */
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.1) 0px,
                rgba(0,0,0,0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scanlines"></div>
        <div id="score">–°–ß–Å–¢: 0</div>
        <div id="doubleJumpIndicator">2X –ü–†–´–ñ–û–ö: –ì–û–¢–û–í</div>
        
        <div id="startScreen">
            <h2>üê± –ö–û–¢–ò–ö –ë–ï–ñ–ò–¢</h2>
            <p>–ü–†–´–ì–ê–ô –ß–ï–†–ï–ó –ö–ê–ú–ù–ò</p>
            <p>‚ö†Ô∏è –ë–û–ô–°–Ø –Ø–ú!</p>
            <p style="font-size: 14px; color: #0f0;">–ü–†–û–ë–ï–õ –∏–ª–∏ –ö–õ–ò–ö –¥–ª—è –ø—Ä—ã–∂–∫–∞</p>
            <p style="font-size: 13px; color: #ff0;">ü¶ò –í –≤–æ–∑–¥—É—Ö–µ –º–æ–∂–Ω–æ –µ—â—ë —Ä–∞–∑!</p>
            <button id="startBtn">‚ñ∂ –ù–ê–ß–ê–¢–¨</button>
        </div>
        
        <div id="gameOver">
            <h2>üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
            <p>–°–ß–Å–¢: <span id="finalScore">0</span></p>
            <button id="restartBtn">‚Üª –ó–ê–ù–û–í–û</button>
        </div>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        try {
            const tg = window.Telegram?.WebApp;
            if (tg) {
                tg.expand(); tg.ready(); tg.BackButton.show();
                tg.BackButton.onClick(() => {
                    window.location.href = 'https://juvenalshaeffer-art.github.io/tamagotchi/';
                });
            }
        } catch(e) {}

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const doubleJumpIndicator = document.getElementById('doubleJumpIndicator');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // üéÆ DENDY –ü–ê–†–ê–ú–ï–¢–†–´
        const PIXEL_SIZE = 4; // –†–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ "–ø–∏–∫—Å–µ–ª—è"
        const JUMP_VELOCITY = -15;
        const DOUBLE_JUMP_VELOCITY = -12;
        const GRAVITY = 0.8;
        const BASE_SPEED = 5;
        const CAT_WIDTH = 70;
        const CAT_HEIGHT = 70;
        
        const SINGLE_JUMP_DISTANCE = Math.abs((2 * JUMP_VELOCITY / GRAVITY) * BASE_SPEED);
        const MAX_JUMP_DISTANCE = SINGLE_JUMP_DISTANCE * 1.5;
        const MIN_GAP = (MAX_JUMP_DISTANCE * 1.5) + CAT_WIDTH;

        // üé® DENDY –ü–ê–õ–ò–¢–†–ê
        const COLORS = {
            sky: '#5C94FC',      // –ù–µ–±–æ NES
            ground: '#C84C0C',   // –ó–µ–º–ª—è
            grass: '#00A800',    // –¢—Ä–∞–≤–∞
            cat: '#A0A0A0',      // –ö–æ—Ç —Å–µ—Ä—ã–π
            catDark: '#606060',  // –ö–æ—Ç —Ç—ë–º–Ω—ã–π
            catLight: '#D0D0D0', // –ö–æ—Ç —Å–≤–µ—Ç–ª—ã–π
            catEye: '#F8B800',   // –ì–ª–∞–∑–∞
            rock: '#808080',     // –ö–∞–º–µ–Ω—å
            rockDark: '#505050', // –ö–∞–º–µ–Ω—å —Ç—ë–º–Ω—ã–π
            pit: '#583820',      // –Ø–º–∞
            tree: '#00A800',     // –î–µ—Ä–µ–≤–æ
            trunk: '#804000',    // –°—Ç–≤–æ–ª
            cloud: '#FFFFFF',    // –û–±–ª–∞–∫–æ
            white: '#FFFFFF',
            black: '#000000'
        };

        let gameRunning = false;
        let score = 0;
        let speed = BASE_SPEED;
        let frame = 0;

        const cat = {
            x: 80, y: 0, width: CAT_WIDTH, height: CAT_HEIGHT,
            velocityY: 0, jumping: false, groundY: 0,
            inPit: false, canDoubleJump: false, hasDoubleJumped: false,
            animFrame: 0
        };

        let obstacles = [];
        let pits = [];
        let backgroundElements = [];

        function updateDoubleJumpIndicator() {
            if (cat.canDoubleJump && !cat.hasDoubleJumped) {
                doubleJumpIndicator.textContent = '2X –ü–†–´–ñ–û–ö: –ì–û–¢–û–í';
                doubleJumpIndicator.style.color = '#0f0';
            } else {
                doubleJumpIndicator.textContent = '2X –ü–†–´–ñ–û–ö: –ù–ï–¢';
                doubleJumpIndicator.style.color = '#666';
            }
        }

        // üê± –†–ò–°–£–ï–ú –ö–û–¢–ò–ö–ê –í –ü–ò–ö–°–ï–õ–¨–ù–û–ú –°–¢–ò–õ–ï
        function drawPixelCat() {
            const x = Math.floor(cat.x);
            const y = Math.floor(cat.y);
            const p = PIXEL_SIZE; // pixel size

            ctx.save();
            
            // –¢–µ–Ω—å
            if (!cat.inPit) {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(x + 10, y + CAT_HEIGHT - 5, CAT_WIDTH - 20, 8);
            }

            // –•–≤–æ—Å—Ç (–∞–Ω–∏–º–∞—Ü–∏—è)
            ctx.fillStyle = COLORS.cat;
            const tailWag = cat.inPit ? 0 : Math.sin(frame * 0.3) * 8;
            ctx.fillRect(x - 20, y + 20 + tailWag, 20, 8);
            ctx.fillRect(x - 28, y + 15 + tailWag, 12, 8);

            // –¢–µ–ª–æ
            ctx.fillStyle = COLORS.cat;
            ctx.fillRect(x + 10, y + 25, 45, 25);
            
            // –ü–æ–ª–æ—Å–∫–∏ –Ω–∞ —Ç–µ–ª–µ
            ctx.fillStyle = COLORS.catDark;
            ctx.fillRect(x + 20, y + 28, 6, 20);
            ctx.fillRect(x + 32, y + 28, 6, 20);

            // –ì–æ–ª–æ–≤–∞
            ctx.fillStyle = COLORS.cat;
            ctx.fillRect(x + 45, y + 15, 25, 22);

            // –£—à–∏
            ctx.fillStyle = COLORS.cat;
            ctx.fillRect(x + 48, y + 8, 6, 10);
            ctx.fillRect(x + 62, y + 8, 6, 10);
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(x + 50, y + 10, 4, 6);
            ctx.fillRect(x + 64, y + 10, 4, 6);

            // –ì–ª–∞–∑–∞
            ctx.fillStyle = COLORS.white;
            ctx.fillRect(x + 52, y + 18, 8, 8);
            ctx.fillRect(x + 64, y + 18, 8, 8);
            ctx.fillStyle = COLORS.catEye;
            ctx.fillRect(x + 54, y + 20, 4, 4);
            ctx.fillRect(x + 66, y + 20, 4, 4);
            ctx.fillStyle = COLORS.black;
            ctx.fillRect(x + 55, y + 21, 2, 2);
            ctx.fillRect(x + 67, y + 21, 2, 2);

            // –ù–æ—Å
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(x + 68, y + 26, 4, 4);

            // –£—Å—ã
            ctx.fillStyle = COLORS.white;
            ctx.fillRect(x + 42, y + 24, 10, 2);
            ctx.fillRect(x + 42, y + 28, 10, 2);

            // –õ–∞–ø—ã (–∞–Ω–∏–º–∞—Ü–∏—è –±–µ–≥–∞)
            const legOffset = cat.jumping || cat.inPit ? 0 : Math.sin(frame * 0.4) * 10;
            ctx.fillStyle = COLORS.cat;
            
            // –ó–∞–¥–Ω–∏–µ
            ctx.fillRect(x + 15 + legOffset, y + 48, 8, 12);
            ctx.fillRect(x + 30 - legOffset, y + 48, 8, 12);
            
            // –ü–µ—Ä–µ–¥–Ω–∏–µ
            ctx.fillRect(x + 48 + legOffset, y + 48, 8, 12);
            ctx.fillRect(x + 60 - legOffset, y + 48, 8, 12);

            ctx.restore();
        }

        // üå≤ –î–ï–†–ï–í–û –í –ü–ò–ö–°–ï–õ–¨–ù–û–ú –°–¢–ò–õ–ï
        class PixelTree {
            constructor(x) {
                this.x = x || canvas.width + Math.random() * 200;
                this.height = 60 + Math.random() * 80;
                this.speed = speed * 0.3;
                this.variation = Math.floor(Math.random() * 2);
            }
            update() { this.x -= this.speed; }
            draw() {
                const p = PIXEL_SIZE;
                const groundY = canvas.height - 60;
                
                // –°—Ç–≤–æ–ª
                ctx.fillStyle = COLORS.trunk;
                ctx.fillRect(this.x - 6, groundY - this.height, 12, this.height);
                
                // –ö—Ä–æ–Ω–∞
                ctx.fillStyle = COLORS.tree;
                if (this.variation === 0) {
                    // –ö—Ä—É–≥–ª–∞—è
                    ctx.fillRect(this.x - 25, groundY - this.height - 35, 50, 40);
                    ctx.fillRect(this.x - 20, groundY - this.height - 45, 40, 15);
                } else {
                    // –¢—Ä–µ—É–≥–æ–ª—å–Ω–∞—è (—ë–ª–∫–∞)
                    ctx.fillRect(this.x - 30, groundY - this.height - 20, 60, 25);
                    ctx.fillRect(this.x - 25, groundY - this.height - 40, 50, 25);
                    ctx.fillRect(this.x - 20, groundY - this.height - 55, 40, 20);
                }
            }
        }

        // ‚òÅÔ∏è –û–ë–õ–ê–ö–û –í –ü–ò–ö–°–ï–õ–¨–ù–û–ú –°–¢–ò–õ–ï
        class PixelCloud {
            constructor(x) {
                this.x = x || canvas.width + Math.random() * 300;
                this.y = 40 + Math.random() * 100;
                this.width = 60 + Math.random() * 50;
                this.speed = speed * 0.15;
            }
            update() { this.x -= this.speed; }
            draw() {
                ctx.fillStyle = COLORS.cloud;
                ctx.fillRect(this.x, this.y, this.width, 20);
                ctx.fillRect(this.x + 15, this.y - 12, this.width - 30, 15);
            }
        }

        // ü™® –ö–ê–ú–ï–ù–¨ –í –ü–ò–ö–°–ï–õ–¨–ù–û–ú –°–¢–ò–õ–ï
        class PixelRock {
            constructor(x) {
                this.width = 40 + Math.random() * 30;
                this.height = 25 + Math.random() * 20;
                this.x = x || canvas.width;
                this.y = canvas.height - 60 - this.height;
                this.markedForDeletion = false;
            }
            update() {
                this.x -= speed;
                if (this.x + this.width < 0) {
                    this.markedForDeletion = true;
                    score++;
                    scoreElement.textContent = '–°–ß–Å–¢: ' + score;
                    if (score % 5 === 0) speed += 0.5;
                }
            }
            draw() {
                ctx.fillStyle = COLORS.rock;
                // –ü–æ–ª—É–∫—Ä—É–≥–ª–∞—è —Ñ–æ—Ä–º–∞ –∏–∑ –ø–∏–∫—Å–µ–ª–µ–π
                const steps = 8;
                for (let i = 0; i < steps; i++) {
                    const y = this.y + this.height - (i * this.height / steps);
                    const width = this.width * Math.sin((i / steps) * Math.PI);
                    ctx.fillRect(this.x + (this.width - width) / 2, y, width, this.height / steps);
                }
                
                // –ë–ª–∏–∫
                ctx.fillStyle = COLORS.rockDark;
                ctx.fillRect(this.x + 8, this.y + 8, this.width - 16, 6);
            }
        }

        // üï≥Ô∏è –Ø–ú–ê –í –ü–ò–ö–°–ï–õ–¨–ù–û–ú –°–¢–ò–õ–ï
        class PixelPit {
            constructor(x) {
                this.width = 60 + Math.random() * 40;
                this.depth = 50 + Math.random() * 30;
                this.x = x || canvas.width;
                this.y = canvas.height - 60;
                this.markedForDeletion = false;
            }
            update() {
                this.x -= speed;
                if (this.x + this.width < 0) this.markedForDeletion = true;
            }
            draw() {
                ctx.fillStyle = COLORS.pit;
                ctx.fillRect(this.x, this.y, this.width, this.depth);
                
                // –¢–µ–Ω—å –≤–Ω—É—Ç—Ä–∏
                ctx.fillStyle = '#382818';
                ctx.fillRect(this.x + 10, this.y + 10, this.width - 20, this.depth - 15);
            }
        }

        function initBackground() {
            backgroundElements = [];
            for (let i = 0; i < 6; i++) backgroundElements.push(new PixelTree(i * 180));
            for (let i = 0; i < 5; i++) backgroundElements.push(new PixelCloud(i * 220));
        }

        function drawBackground() {
            // –ù–µ–±–æ –≥—Ä–∞–¥–∏–µ–Ω—Ç
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, COLORS.sky);
            gradient.addColorStop(0.6, '#88C8F8');
            gradient.addColorStop(1, COLORS.ground);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // –î–∞–ª—å–Ω–∏–µ —Ö–æ–ª–º—ã (–ø–∏–∫—Å–µ–ª—å–Ω—ã–µ)
            ctx.fillStyle = '#78B850';
            ctx.fillRect(0, canvas.height - 100, canvas.width, 40);
        }

        function updateBackground() {
            backgroundElements.forEach((el, i) => {
                el.speed = speed * (el instanceof PixelTree ? 0.3 : 0.15);
                el.update();
                el.draw();
                if (el.x < -100) {
                    backgroundElements.splice(i, 1);
                    backgroundElements.push(el instanceof PixelTree ? new PixelTree() : new PixelCloud());
                }
            });
        }

        function jump() {
            if (!gameRunning || cat.inPit) return;
            if (!cat.jumping) {
                cat.velocityY = JUMP_VELOCITY;
                cat.jumping = true;
                cat.canDoubleJump = true;
                cat.hasDoubleJumped = false;
            } else if (cat.canDoubleJump && !cat.hasDoubleJumped) {
                cat.velocityY = DOUBLE_JUMP_VELOCITY;
                cat.hasDoubleJumped = true;
                cat.canDoubleJump = false;
            }
            updateDoubleJumpIndicator();
        }

        function updateCat() {
            if (cat.inPit) {
                cat.velocityY += 1.2;
                cat.y += cat.velocityY;
                if (cat.y >= cat.groundY + 50) gameOver();
                return;
            }
            cat.velocityY += GRAVITY;
            cat.y += cat.velocityY;
            if (cat.y >= cat.groundY) {
                cat.y = cat.groundY;
                cat.jumping = false;
                cat.velocityY = 0;
                cat.canDoubleJump = false;
                cat.hasDoubleJumped = false;
            }
            updateDoubleJumpIndicator();
        }

        const groundHeight = 60;

        function handleObstacles() {
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - MIN_GAP) {
                if (Math.random() < 0.03) {
                    obstacles.push(new PixelRock(canvas.width + Math.random() * 100));
                }
            }
            if (pits.length === 0 || pits[pits.length - 1].x < canvas.width - MIN_GAP * 1.5) {
                if (Math.random() < 0.015) {
                    pits.push(new PixelPit(canvas.width + Math.random() * 100));
                }
            }

            obstacles.forEach((obs, i) => {
                obs.update();
                obs.draw();
                const hit = cat.x < obs.x + obs.width && cat.x + cat.width > obs.x &&
                           cat.y + cat.height > obs.y && cat.y < obs.y + obs.height;
                if (hit) {
                    if (cat.velocityY > 0 && cat.y + cat.height - obs.y < 20) {
                        obs.markedForDeletion = true;
                        cat.velocityY = -5;
                        score++;
                        scoreElement.textContent = '–°–ß–Å–¢: ' + score;
                        if (score % 5 === 0) speed += 0.5;
                    } else {
                        gameOver();
                    }
                }
                if (obs.markedForDeletion) obstacles.splice(i, 1);
            });

            pits.forEach((pit, i) => {
                pit.update();
                pit.draw();
                const cx = cat.x + cat.width / 2;
                if (cat.y >= cat.groundY - 5 && !cat.jumping &&
                    cx > pit.x + 10 && cx < pit.x + pit.width - 10) {
                    cat.inPit = true;
                }
                if (pit.markedForDeletion) pits.splice(i, 1);
            });
        }

        function drawGround() {
            ctx.fillStyle = COLORS.ground;
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 12);
            
            // –ü–∏–∫—Å–µ–ª—å–Ω–∞—è —Ç—Ä–∞–≤–∞
            ctx.fillStyle = '#00D800';
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.fillRect(i, canvas.height - groundHeight - 4, 8, 4);
            }
        }

        function gameOver() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            gameOverScreen.style.display = 'block';
        }

        function startGame() {
            score = 0; speed = BASE_SPEED; frame = 0;
            obstacles = []; pits = [];
            cat.y = cat.groundY; cat.velocityY = 0;
            cat.jumping = false; cat.inPit = false;
            cat.canDoubleJump = false; cat.hasDoubleJumped = false;
            scoreElement.textContent = '–°–ß–Å–¢: 0';
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none';
            gameRunning = true;
            initBackground();
            updateDoubleJumpIndicator();
            animate();
        }

        function animate() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            cat.groundY = canvas.height - groundHeight - cat.height;
            drawBackground();
            updateBackground();
            drawGround();
            updateCat();
            drawPixelCat();
            handleObstacles();
            frame++;
            requestAnimationFrame(animate);
        }

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { e.preventDefault(); if (gameRunning) jump(); }
        });
        canvas.addEventListener('click', () => { if (gameRunning) jump(); });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); if (gameRunning) jump();
        }, { passive: false });
    </script>
</body>
</html>
