<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ö–æ—Ç–∏–∫ –±–µ–∂–∏—Ç - Sega Style</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body {
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; background: #000;
            font-family: 'Arial', sans-serif; overflow: hidden; width: 100vw; height: 100vh;
        }
        #gameContainer { position: relative; width: 100%; height: 100%; }
        #gameCanvas { 
            display: block; width: 100%; height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #score {
            position: absolute; top: 15px; left: 15px; font-size: 22px;
            font-weight: bold; color: #fff; text-shadow: 2px 2px 0 #000;
            padding: 10px 20px; z-index: 10;
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(180deg, #0080FF 0%, #004080 100%);
            border: 3px solid #fff;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        #doubleJumpIndicator {
            position: absolute; top: 15px; right: 15px; font-size: 16px;
            padding: 10px 20px; z-index: 10;
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(180deg, #00FF00 0%, #008000 100%);
            border: 3px solid #fff;
            color: #000; text-shadow: none;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        #startScreen, #gameOver {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: linear-gradient(180deg, #1a1a4e 0%, #0a0a2e 100%);
            padding: 40px 50px; text-align: center;
            border: 4px solid #00FFFF;
            box-shadow: 0 0 20px rgba(0,255,255,0.5), inset 0 0 30px rgba(0,0,0,0.8);
            z-index: 20;
            min-width: 300px;
        }
        #gameOver { display: none; border-color: #FF0000; box-shadow: 0 0 20px rgba(255,0,0,0.5), inset 0 0 30px rgba(0,0,0,0.8); }
        h2 { 
            margin: 0 0 20px 0; 
            font-size: 32px; 
            font-family: 'Arial Black', sans-serif;
            background: linear-gradient(180deg, #FFFF00 0%, #FF8000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 3px 3px 0 #000;
            letter-spacing: 2px;
        }
        p { margin: 12px 0; color: #fff; font-size: 16px; text-shadow: 1px 1px 0 #000; }
        button {
            margin-top: 20px; padding: 15px 50px; font-size: 20px;
            background: linear-gradient(180deg, #00FF00 0%, #008000 100%);
            color: #000; border: 3px solid #fff;
            cursor: pointer; font-weight: bold;
            font-family: 'Arial Black', sans-serif;
            box-shadow: 0 4px 0 #004000, 0 6px 10px rgba(0,0,0,0.5);
        }
        button:active { 
            transform: translateY(4px);
            box-shadow: 0 0 0 #004000, 0 2px 5px rgba(0,0,0,0.5);
        }
        
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.15) 0px,
                rgba(0,0,0,0.15) 2px,
                transparent 2px,
                transparent 4px
            );
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
        }
        
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.4) 100%);
            pointer-events: none;
            z-index: 101;
        }
        
        .sega-logo {
            font-size: 24px;
            font-weight: bold;
            color: #00FFFF;
            text-shadow: 2px 2px 0 #000080, -1px -1px 0 #000080;
            margin-bottom: 15px;
            letter-spacing: 4px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scanlines"></div>
        <div id="vignette"></div>
        <div id="score">–°–ß–Å–¢: 0</div>
        <div id="doubleJumpIndicator">2X –ü–†–´–ñ–û–ö: –ì–û–¢–û–í</div>
        
        <div id="startScreen">
            <div class="sega-logo">‚ö° SEGA STYLE ‚ö°</div>
            <h2>üê± –ö–û–¢–ò–ö –ë–ï–ñ–ò–¢</h2>
            <p>ü™® –ü–†–´–ì–ê–ô –ß–ï–†–ï–ó –ö–ê–ú–ù–ò</p>
            <p>üï≥Ô∏è –ò–ó–ë–ï–ì–ê–ô –Ø–ú!</p>
            <p style="color: #00FF00;">–ü–†–û–ë–ï–õ –∏–ª–∏ –ö–õ–ò–ö –¥–ª—è –ø—Ä—ã–∂–∫–∞</p>
            <p style="color: #FFFF00; font-size: 14px;">ü¶ò –î–≤–æ–π–Ω–æ–π –ø—Ä—ã–∂–æ–∫ –≤ –≤–æ–∑–¥—É—Ö–µ!</p>
            <button id="startBtn">‚ñ∂ –ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        </div>
        
        <div id="gameOver">
            <div class="sega-logo" style="color: #FF0000;">üíÄ GAME OVER üíÄ</div>
            <h2>–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê</h2>
            <p>–§–ò–ù–ê–õ–¨–ù–´–ô –°–ß–Å–¢: <span id="finalScore" style="color: #00FF00; font-weight: bold;">0</span></p>
            <button id="restartBtn">‚Üª –ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button>
        </div>
    </div>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        try {
            const tg = window.Telegram?.WebApp;
            if (tg) {
                tg.expand(); tg.ready(); tg.BackButton.show();
                tg.BackButton.onClick(() => {
                    window.location.href = 'https://juvenalshaeffer-art.github.io/tamagotchi/';
                });
            }
        } catch(e) {}

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const doubleJumpIndicator = document.getElementById('doubleJumpIndicator');
        const startScreen = document.getElementById('startScreen');
        const startBtn = document.getElementById('startBtn');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const PIXEL_SIZE = 2;
        const JUMP_VELOCITY = -15;
        const DOUBLE_JUMP_VELOCITY = -12;
        const GRAVITY = 0.8;
        const BASE_SPEED = 5;
        const CAT_WIDTH = 70;
        const CAT_HEIGHT = 70;
        
        const SINGLE_JUMP_DISTANCE = Math.abs((2 * JUMP_VELOCITY / GRAVITY) * BASE_SPEED);
        const MAX_JUMP_DISTANCE = SINGLE_JUMP_DISTANCE * 1.5;
        const MIN_GAP = (MAX_JUMP_DISTANCE * 1.5) + CAT_WIDTH;

        const COLORS = {
            sky1: '#0060A0', sky2: '#0080C0', sky3: '#40A0E0',
            ground: '#804000', groundLight: '#A06020',
            grass: '#00A800', grassLight: '#00D000',
            cat1: '#C0C0C0', cat2: '#A0A0A0', cat3: '#808080',
            cat4: '#606060', catLight: '#E0E0E0', catShadow: '#404040',
            catEye: '#FFD000', catEyeDark: '#804000',
            catNose: '#FF80A0', catInner: '#FFC0D0',
            rock1: '#808080', rock2: '#606060', rock3: '#A0A0A0', rockShadow: '#404040',
            pit1: '#604020', pit2: '#403018', pit3: '#201810',
            tree1: '#008000', tree2: '#00A000', tree3: '#00C000',
            trunk1: '#603000', trunk2: '#804000',
            cloud1: '#FFFFFF', cloud2: '#E0E0E0', cloud3: '#C0C0C0',
            mountain1: '#406080', mountain2: '#6080A0', mountain3: '#80A0C0',
            ui1: '#00FFFF', ui2: '#0080FF', ui3: '#FFFF00', ui4: '#00FF00', ui5: '#FF0000'
        };

        let gameRunning = false;
        let score = 0;
        let speed = BASE_SPEED;
        let frame = 0;

        const cat = {
            x: 80, y: 0, width: CAT_WIDTH, height: CAT_HEIGHT,
            velocityY: 0, jumping: false, groundY: 0,
            inPit: false, canDoubleJump: false, hasDoubleJumped: false,
            animFrame: 0, direction: 1
        };

        let obstacles = [];
        let pits = [];
        let backgroundElements = [];
        let mountains = [];

        function updateDoubleJumpIndicator() {
            if (cat.canDoubleJump && !cat.hasDoubleJumped) {
                doubleJumpIndicator.textContent = '2X –ü–†–´–ñ–û–ö: –ì–û–¢–û–í';
                doubleJumpIndicator.style.background = 'linear-gradient(180deg, #00FF00 0%, #008000 100%)';
            } else {
                doubleJumpIndicator.textContent = '2X –ü–†–´–ñ–û–ö: –ù–ï–¢';
                doubleJumpIndicator.style.background = 'linear-gradient(180deg, #808080 0%, #404040 100%)';
            }
        }

        class Mountain {
            constructor(x) {
                this.x = x || canvas.width + Math.random() * 300;
                this.width = 150 + Math.random() * 200;
                this.height = 100 + Math.random() * 150;
                this.speed = speed * 0.1;
                this.peaks = 3 + Math.floor(Math.random() * 3);
                this.color = Math.random() > 0.5 ? COLORS.mountain1 : COLORS.mountain2;
            }
            update() { this.x -= this.speed; }
            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, canvas.height - 60);
                for (let i = 0; i <= this.peaks; i++) {
                    const px = this.x + (i * this.width / this.peaks);
                    const py = canvas.height - 60 - this.height + Math.sin(i) * 30;
                    ctx.lineTo(px, py);
                }
                ctx.lineTo(this.x + this.width, canvas.height - 60);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#FFFFFF';
                for (let i = 1; i < this.peaks; i++) {
                    const px = this.x + (i * this.width / this.peaks);
                    const py = canvas.height - 60 - this.height + Math.sin(i) * 30;
                    ctx.beginPath();
                    ctx.moveTo(px - 15, py + 20);
                    ctx.lineTo(px, py);
                    ctx.lineTo(px + 15, py + 20);
                    ctx.fill();
                }
            }
        }

        class SegaTree {
            constructor(x) {
                this.x = x || canvas.width + Math.random() * 200;
                this.height = 80 + Math.random() * 100;
                this.speed = speed * 0.3;
                this.variation = Math.floor(Math.random() * 3);
            }
            update() { this.x -= this.speed; }
            draw() {
                const groundY = canvas.height - 60;
                
                ctx.fillStyle = COLORS.trunk1;
                ctx.fillRect(this.x - 8, groundY - this.height, 16, this.height);
                ctx.fillStyle = COLORS.trunk2;
                ctx.fillRect(this.x - 6, groundY - this.height + 10, 8, this.height - 20);
                ctx.fillStyle = '#402000';
                ctx.fillRect(this.x - 4, groundY - this.height + 20, 4, this.height - 40);
                
                if (this.variation === 0) {
                    ctx.fillStyle = COLORS.tree1;
                    ctx.fillRect(this.x - 35, groundY - this.height - 50, 70, 60);
                    ctx.fillStyle = COLORS.tree2;
                    ctx.fillRect(this.x - 30, groundY - this.height - 45, 60, 50);
                    ctx.fillStyle = COLORS.tree3;
                    ctx.fillRect(this.x - 25, groundY - this.height - 40, 50, 40);
                } else if (this.variation === 1) {
                    ctx.fillStyle = COLORS.tree1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, groundY - this.height - 80);
                    ctx.lineTo(this.x - 40, groundY - this.height - 20);
                    ctx.lineTo(this.x + 40, groundY - this.height - 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = COLORS.tree2;
                    ctx.beginPath();
                    ctx.moveTo(this.x, groundY - this.height - 60);
                    ctx.lineTo(this.x - 35, groundY - this.height - 10);
                    ctx.lineTo(this.x + 35, groundY - this.height - 10);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.fillStyle = COLORS.trunk1;
                    ctx.fillRect(this.x - 6, groundY - this.height - 30, 12, this.height + 30);
                    ctx.fillStyle = COLORS.tree1;
                    for (let i = 0; i < 7; i++) {
                        const angle = (i / 7) * Math.PI - Math.PI / 2;
                        ctx.fillRect(
                            this.x + Math.cos(angle) * 30 - 3,
                            groundY - this.height - 35 + Math.sin(angle) * 10,
                            6, 25
                        );
                    }
                }
            }
        }

        class SegaCloud {
            constructor(x) {
                this.x = x || canvas.width + Math.random() * 300;
                this.y = 30 + Math.random() * 120;
                this.width = 80 + Math.random() * 80;
                this.speed = speed * 0.15;
            }
            update() { this.x -= this.speed; }
            draw() {
                ctx.fillStyle = COLORS.cloud1;
                ctx.fillRect(this.x, this.y, this.width, 25);
                ctx.fillRect(this.x + 15, this.y - 15, this.width - 30, 20);
                ctx.fillRect(this.x + 30, this.y - 25, this.width - 60, 15);
                
                ctx.fillStyle = COLORS.cloud2;
                ctx.fillRect(this.x + 10, this.y + 20, this.width - 40, 8);
                ctx.fillRect(this.x + 25, this.y + 5, this.width - 60, 10);
            }
        }

        // üê± –ö–û–¢–ò–ö ‚Äî –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô (–±–µ–∑ —Ç–µ–Ω–∏, —É—Å—ã —Å –¥–≤—É—Ö —Å—Ç–æ—Ä–æ–Ω)
        function drawSegaCat() {
            const x = Math.floor(cat.x);
            const y = Math.floor(cat.y);
            const p = PIXEL_SIZE;

            ctx.save();

            // ‚ùå –¢–ï–ù–¨ –£–ë–†–ê–ù–ê

            // –•–≤–æ—Å—Ç (–∞–Ω–∏–º–∞—Ü–∏—è)
            const tailWag = cat.inPit ? 0 : Math.sin(frame * 0.25) * 12;
            
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x - 35, y + 35 + tailWag, 25, 10);
            ctx.fillRect(x - 45, y + 30 + tailWag, 15, 10);
            ctx.fillStyle = COLORS.cat3;
            ctx.fillRect(x - 35, y + 37 + tailWag, 25, 6);
            ctx.fillRect(x - 45, y + 32 + tailWag, 15, 6);

            // –õ–∞–ø—ã (–∞–Ω–∏–º–∞—Ü–∏—è)
            const legOffset = cat.jumping || cat.inPit ? 0 : Math.sin(frame * 0.35) * 12;
            
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x + 18 + legOffset, y + 52, 10, 14);
            ctx.fillRect(x + 35 - legOffset, y + 52, 10, 14);
            
            ctx.fillStyle = COLORS.catInner;
            ctx.fillRect(x + 18 + legOffset, y + 62, 10, 4);
            ctx.fillRect(x + 35 - legOffset, y + 62, 10, 4);

            // –¢–µ–ª–æ
            ctx.fillStyle = COLORS.cat1;
            ctx.fillRect(x + 15, y + 30, 50, 28);
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x + 15, y + 45, 50, 13);
            
            // –ü–æ–ª–æ—Å–∫–∏ –Ω–∞ —Å–ø–∏–Ω–µ
            ctx.fillStyle = COLORS.cat4;
            ctx.fillRect(x + 22, y + 32, 8, 24);
            ctx.fillRect(x + 38, y + 32, 8, 24);
            ctx.fillRect(x + 54, y + 32, 6, 24);

            // –ü–µ—Ä–µ–¥–Ω–∏–µ –ª–∞–ø—ã
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x + 52 + legOffset, y + 52, 10, 14);
            ctx.fillRect(x + 67 - legOffset, y + 52, 10, 14);
            ctx.fillStyle = COLORS.catInner;
            ctx.fillRect(x + 52 + legOffset, y + 62, 10, 4);
            ctx.fillRect(x + 67 - legOffset, y + 62, 10, 4);

            // –ì–æ–ª–æ–≤–∞
            ctx.fillStyle = COLORS.cat1;
            ctx.fillRect(x + 50, y + 18, 32, 26);
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x + 50, y + 32, 32, 12);

            // –£—à–∏
            ctx.fillStyle = COLORS.cat2;
            ctx.fillRect(x + 52, y + 10, 10, 12);
            ctx.fillRect(x + 70, y + 10, 10, 12);
            ctx.fillStyle = COLORS.catInner;
            ctx.fillRect(x + 54, y + 12, 6, 8);
            ctx.fillRect(x + 72, y + 12, 6, 8);

            // –ì–ª–∞–∑–∞
            ctx.fillStyle = COLORS.catLight;
            ctx.fillRect(x + 56, y + 22, 12, 12);
            ctx.fillRect(x + 72, y + 22, 12, 12);
            
            ctx.fillStyle = COLORS.catEye;
            ctx.fillRect(x + 58, y + 24, 8, 8);
            ctx.fillRect(x + 74, y + 24, 8, 8);
            
            ctx.fillStyle = COLORS.catEyeDark;
            ctx.fillRect(x + 60, y + 26, 4, 4);
            ctx.fillRect(x + 76, y + 26, 4, 4);
            
            // –ë–ª–∏–∫ –≤ –≥–ª–∞–∑–∞—Ö
            ctx.fillStyle = COLORS.catLight;
            ctx.fillRect(x + 61, y + 25, 2, 2);
            ctx.fillRect(x + 77, y + 25, 2, 2);

            // –ù–æ—Å
            ctx.fillStyle = COLORS.catNose;
            ctx.fillRect(x + 78, y + 32, 6, 5);

            // ‚úÖ –£–°–´ –° –û–ë–ï–ò–• –°–¢–û–†–û–ù
            ctx.fillStyle = COLORS.catLight;
            // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ (–±—ã–ª–æ)
            ctx.fillRect(x + 48, y + 30, 12, 2);
            ctx.fillRect(x + 48, y + 34, 12, 2);
            ctx.fillRect(x + 48, y + 38, 12, 2);
            // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ (–¥–æ–±–∞–≤–ª–µ–Ω–æ)
            ctx.fillRect(x + 82, y + 30, 12, 2);
            ctx.fillRect(x + 82, y + 34, 12, 2);
            ctx.fillRect(x + 82, y + 38, 12, 2);

            // –û—à–µ–π–Ω–∏–∫
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x + 52, y + 42, 28, 5);
            ctx.fillStyle = '#FFD000';
            ctx.fillRect(x + 64, y + 43, 6, 6);

            ctx.restore();
        }

        class SegaRock {
            constructor(x) {
                this.width = 45 + Math.random() * 35;
                this.height = 30 + Math.random() * 25;
                this.x = x || canvas.width;
                this.y = canvas.height - 60 - this.height;
                this.markedForDeletion = false;
            }
            update() {
                this.x -= speed;
                if (this.x + this.width < 0) {
                    this.markedForDeletion = true;
                    score++;
                    scoreElement.textContent = '–°–ß–Å–¢: ' + score;
                    if (score % 5 === 0) speed += 0.5;
                }
            }
            draw() {
                ctx.fillStyle = COLORS.rock1;
                ctx.fillRect(this.x + 10, this.y, this.width - 20, this.height);
                ctx.fillRect(this.x, this.y + 10, this.width, this.height - 10);
                
                ctx.fillStyle = COLORS.rock2;
                ctx.fillRect(this.x + 15, this.y + 5, this.width - 30, this.height - 10);
                
                ctx.fillStyle = COLORS.rock3;
                ctx.fillRect(this.x + 12, this.y + 8, this.width - 35, 8);
                ctx.fillRect(this.x + 18, this.y + 12, this.width - 40, 6);
                
                ctx.fillStyle = COLORS.rockShadow;
                ctx.fillRect(this.x + 8, this.y + this.height - 8, this.width - 16, 8);
                
                ctx.fillStyle = '#505050';
                ctx.fillRect(this.x + 20, this.y + 15, 2, 12);
                ctx.fillRect(this.x + 35, this.y + 18, 2, 10);
                ctx.fillRect(this.x + this.width - 25, this.y + 12, 2, 14);
            }
        }

        class SegaPit {
            constructor(x) {
                this.width = 70 + Math.random() * 50;
                this.depth = 55 + Math.random() * 35;
                this.x = x || canvas.width;
                this.y = canvas.height - 60;
                this.markedForDeletion = false;
            }
            update() {
                this.x -= speed;
                if (this.x + this.width < 0) this.markedForDeletion = true;
            }
            draw() {
                ctx.fillStyle = COLORS.pit1;
                ctx.fillRect(this.x, this.y, this.width, this.depth);
                
                ctx.fillStyle = COLORS.pit2;
                ctx.fillRect(this.x + 8, this.y + 8, this.width - 16, this.depth - 15);
                
                ctx.fillStyle = COLORS.pit3;
                ctx.fillRect(this.x + 15, this.y + 20, this.width - 30, this.depth - 30);
                
                ctx.fillStyle = COLORS.grass;
                ctx.fillRect(this.x - 5, this.y - 5, this.width + 10, 8);
                ctx.fillStyle = COLORS.grassLight;
                ctx.fillRect(this.x - 3, this.y - 3, this.width + 6, 4);
                
                ctx.fillStyle = COLORS.rock2;
                ctx.fillRect(this.x + 20, this.y + this.depth - 10, 12, 8);
                ctx.fillRect(this.x + this.width - 35, this.y + this.depth - 12, 15, 10);
            }
        }

        function initBackground() {
            backgroundElements = [];
            mountains = [];
            
            for (let i = 0; i < 4; i++) {
                mountains.push(new Mountain(i * 250));
            }
            
            for (let i = 0; i < 7; i++) {
                backgroundElements.push(new SegaTree(i * 160));
            }
            
            for (let i = 0; i < 6; i++) {
                backgroundElements.push(new SegaCloud(i * 200));
            }
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
            gradient.addColorStop(0, COLORS.sky1);
            gradient.addColorStop(0.5, COLORS.sky2);
            gradient.addColorStop(1, COLORS.sky3);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height * 0.6);
        }

        function updateBackground() {
            mountains.forEach((m, i) => {
                m.speed = speed * 0.1;
                m.update();
                m.draw();
                if (m.x + m.width < -100) {
                    mountains.splice(i, 1);
                    mountains.push(new Mountain());
                }
            });
            
            backgroundElements.forEach((el, i) => {
                el.speed = speed * (el instanceof SegaTree ? 0.3 : 0.15);
                el.update();
                el.draw();
                if (el.x < -150) {
                    backgroundElements.splice(i, 1);
                    backgroundElements.push(el instanceof SegaTree ? new SegaTree() : new SegaCloud());
                }
            });
        }

        function jump() {
            if (!gameRunning || cat.inPit) return;
            if (!cat.jumping) {
                cat.velocityY = JUMP_VELOCITY;
                cat.jumping = true;
                cat.canDoubleJump = true;
                cat.hasDoubleJumped = false;
            } else if (cat.canDoubleJump && !cat.hasDoubleJumped) {
                cat.velocityY = DOUBLE_JUMP_VELOCITY;
                cat.hasDoubleJumped = true;
                cat.canDoubleJump = false;
            }
            updateDoubleJumpIndicator();
        }

        function updateCat() {
            if (cat.inPit) {
                cat.velocityY += 1.2;
                cat.y += cat.velocityY;
                if (cat.y >= cat.groundY + 50) gameOver();
                return;
            }
            cat.velocityY += GRAVITY;
            cat.y += cat.velocityY;
            if (cat.y >= cat.groundY) {
                cat.y = cat.groundY;
                cat.jumping = false;
                cat.velocityY = 0;
                cat.canDoubleJump = false;
                cat.hasDoubleJumped = false;
            }
            updateDoubleJumpIndicator();
        }

        const groundHeight = 60;

        function handleObstacles() {
            if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - MIN_GAP) {
                if (Math.random() < 0.03) {
                    obstacles.push(new SegaRock(canvas.width + Math.random() * 100));
                }
            }
            if (pits.length === 0 || pits[pits.length - 1].x < canvas.width - MIN_GAP * 1.5) {
                if (Math.random() < 0.015) {
                    pits.push(new SegaPit(canvas.width + Math.random() * 100));
                }
            }

            obstacles.forEach((obs, i) => {
                obs.update();
                obs.draw();
                const hit = cat.x < obs.x + obs.width && cat.x + cat.width > obs.x &&
                           cat.y + cat.height > obs.y && cat.y < obs.y + obs.height;
                if (hit) {
                    if (cat.velocityY > 0 && cat.y + cat.height - obs.y < 20) {
                        obs.markedForDeletion = true;
                        cat.velocityY = -5;
                        score++;
                        scoreElement.textContent = '–°–ß–Å–¢: ' + score;
                        if (score % 5 === 0) speed += 0.5;
                    } else {
                        gameOver();
                    }
                }
                if (obs.markedForDeletion) obstacles.splice(i, 1);
            });

            pits.forEach((pit, i) => {
                pit.update();
                pit.draw();
                const cx = cat.x + cat.width / 2;
                if (cat.y >= cat.groundY - 5 && !cat.jumping &&
                    cx > pit.x + 10 && cx < pit.x + pit.width - 10) {
                    cat.inPit = true;
                }
                if (pit.markedForDeletion) pits.splice(i, 1);
            });
        }

        function drawGround() {
            ctx.fillStyle = COLORS.ground;
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            
            ctx.fillStyle = COLORS.groundLight;
            ctx.fillRect(0, canvas.height - groundHeight + 15, canvas.width, groundHeight - 15);
            
            ctx.fillStyle = COLORS.grass;
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, 14);
            
            ctx.fillStyle = COLORS.grassLight;
            for (let i = 0; i < canvas.width; i += 25) {
                const h = 6 + Math.sin(i + frame * 0.5) * 3;
                ctx.fillRect(i, canvas.height - groundHeight - h, 12, h);
            }
            
            ctx.fillStyle = '#603000';
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.fillRect(i + (frame % 40), canvas.height - groundHeight + 20, 20, 4);
                ctx.fillRect(i + 15 + (frame % 40), canvas.height - groundHeight + 35, 15, 3);
            }
        }

        function gameOver() {
            gameRunning = false;
            finalScoreElement.textContent = score;
            gameOverScreen.style.display = 'block';
        }

        function startGame() {
            score = 0; speed = BASE_SPEED; frame = 0;
            obstacles = []; pits = [];
            cat.y = cat.groundY; cat.velocityY = 0;
            cat.jumping = false; cat.inPit = false;
            cat.canDoubleJump = false; cat.hasDoubleJumped = false;
            scoreElement.textContent = '–°–ß–Å–¢: 0';
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none';
            gameRunning = true;
            initBackground();
            updateDoubleJumpIndicator();
            animate();
        }

        function animate() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            cat.groundY = canvas.height - groundHeight - cat.height;
            drawBackground();
            updateBackground();
            drawGround();
            updateCat();
            drawSegaCat();
            handleObstacles();
            frame++;
            requestAnimationFrame(animate);
        }

        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { e.preventDefault(); if (gameRunning) jump(); }
        });
        canvas.addEventListener('click', () => { if (gameRunning) jump(); });
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); if (gameRunning) jump();
        }, { passive: false });
    </script>
</body>
</html>
